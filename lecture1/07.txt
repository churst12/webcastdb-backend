so the example posted on the website is does a Java file it's in the example section of the website and follow the link to lecture than recursion and you get there so here's a box trays of the call C32 pretty small numbers cuz I don't want to drop a bunch of boxes but you could you could try this and you should do it on larger numbers just to see no just give yourself a lot of paper and some time and figure it out something like this could occur on the first midterm or even the final or even the second midterm right I do ask people for a box trace of some recursive function well this is pretty simple C32 that's the top invocation of the function that's the top box so this spawns to recursive calls C 2 1 and c22 what's the pattern the pattern is subtract 1 from both or subtract 1 from just one of them so what are these to return you add them that's what this one returns okay so what is this do this is going to be two calls C 1 0 sorry and see one one buckatunna sloppy sorry about that these are both boundary cases hear its boundary because K20 hear its boundary because cables in so both of these return one since both of these return one this guy just add those two and returns to now what is this do well this is also a boundary case because k equals n so this guy just returns one so this guy Returns the sum of these two which is three that's the value of C32 and actually we computed that last time right that was the number of Two element subsets of a 3 element set all right so draw more complicated one as they get bigger though you'll find out what's wrong with this way of computing cnk this is actually a bad way to compute C&K I mean that's not the point of this exercise to find the best way to compute binomial coefficients what's intended here is to understand recursion and recursive thinking so what's wrong with this is just try it for like C5 for something like that you do it and it what you're going to find is you're going to get different boxes that have the same values of K&N and other words you find yourself solving the same sub instant are the same the same sub instance in different parts of this big recursion tree got a much bigger recursion tree and a box with the same values in it occurs in multiple places so you end up wasting a lot of time I can't really bring that problem up without explaining the best programming way to get out of it typically the way you get out of that is if you what you do is you maintain a table of precomputed values and as you whenever you need a new value like see you know whatever some see for some value of Endor some value of K you look in the table and see if you've already computed and if you have you just expect that from the table if you haven't then you then you go into the recursive call did Progressive call that you need and that way you avoid having to do these overlapping or multiple instances of the same sub problem in different boxes in the Box Trace without you're going to suggest having a what louder well cash yeah yeah yeah yeah I mean that is kind of the principle behind cash you know not having to compute the same the same value multiple times but that's not specifically aimed at this recursive procedure okay well that's a nice example still pretty easy though alright so here's another problem again